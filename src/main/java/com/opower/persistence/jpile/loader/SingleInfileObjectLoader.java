package com.opower.persistence.jpile.loader;

import com.google.common.base.Preconditions;
import com.google.common.eventbus.EventBus;
import com.opower.persistence.jpile.infile.InfileDataBuffer;
import com.opower.persistence.jpile.infile.InfileRow;
import com.opower.persistence.jpile.infile.events.EventFirePoint;
import com.opower.persistence.jpile.infile.events.FlushEvent;
import com.opower.persistence.jpile.reflection.PersistenceAnnotationInspector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.persistence.Column;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;

import static com.google.common.base.Throwables.propagate;
import static com.opower.persistence.jpile.reflection.PersistenceAnnotationInspector.getIdValue;
import static com.opower.persistence.jpile.reflection.PersistenceAnnotationInspector.setIdValue;
import static com.opower.persistence.jpile.util.Hex.encodeHexString;

/**
 * An InfileObjectLoader which will update that database using IN FILE format using hibernate annotations.
 *
 * @param <E> the type of object which this class will support
 * @author amir.raminfar
 */
public class SingleInfileObjectLoader<E> extends InfileObjectLoader<E> {
    private static Logger logger = LoggerFactory.getLogger(SingleInfileObjectLoader.class);

    // @TODO we may need to make this atomic to be thread safe
    protected long autoGeneratedId = 0;
    protected final Map<String, Method> mappings = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    protected final Map<Method, SingleInfileObjectLoader<Object>> embeds = new LinkedHashMap<>();

    protected final Class<? extends E> aClass;
    protected PersistenceAnnotationInspector persistenceAnnotationInspector;
    protected boolean allowNull = false;
    protected boolean autoGenerateId = false;
    protected boolean embedChild = false;
    protected String tableName;

    protected final EventBus eventBus;

    SingleInfileObjectLoader(Class<? extends E> aClass, EventBus eventBus) {
        this.aClass = aClass;
        this.eventBus = eventBus;
    }

    /**
     * If the object doesn't have an id it will create a generate a new id. Then it will save the data to the infileRow.
     */
    @Override
    public void convertToInfileRow(E entity, InfileRow infileRow) {
        if (entity == null && this.allowNull) {
            for (int i = 0; i < this.mappings.size(); i++) {
                infileRow.appendNull();
            }
            for (SingleInfileObjectLoader<Object> loader : this.embeds.values()) {
                loader.convertToInfileRow(null, infileRow);
            }
        }
        else {
            if (!this.embedChild && getIdValue(this.persistenceAnnotationInspector, entity) == null) {
                generateAndSetId(entity);
            }
            for (Method m : this.mappings.values()) {
                Object object = invoke(m, entity);
                if (object == null) {
                    infileRow.appendNull();
                    continue;
                }
                if (this.persistenceAnnotationInspector.hasTableAnnotation(object.getClass())) {
                    Long id = (Long) getIdValue(this.persistenceAnnotationInspector, object);
                    Preconditions.checkState(id != null, "@Id for [%s] is null", object);
                    assert id != null;
                    object = id;
                }
                if (object instanceof Date) {
                    infileRow.append((Date) object, m);
                }
                else if (object instanceof Boolean) {
                    infileRow.append((Boolean) object);
                }
                else if (object instanceof byte[]) {
                    infileRow.append(encodeHexString((byte[]) object));
                }
                else if (object instanceof Enum) {
                    infileRow.append(getEnumValueToAppend(m, (Enum <?>) object));
                }
                else if (object instanceof Float) {
                    Column column = this.persistenceAnnotationInspector.findAnnotation(m, Column.class);
                    if (column != null) {
                        int precision = column.precision();
                        int scale = column.scale();
                        if (precision > 0 && scale > 0) {
                            infileRow.append((Float) object, precision, scale);
                            continue;
                        }
                    }
                    infileRow.append(object);
                }
                else {
                    infileRow.append(object);
                }
            }
            for (Map.Entry<Method, SingleInfileObjectLoader<Object>> entry : this.embeds.entrySet()) {
                Object object = invoke(entry.getKey(), entity);
                entry.getValue().convertToInfileRow(object, infileRow);
            }
        }
    }

    /**
     * Get the enum value depending on if the {@code method} specifies the {@link Enumerated} annotation
     * and if it's an {@link EnumType#STRING} to use the {@link Enum#name()}, otherwise use {@link Enum#ordinal()} as specified
     * in the {@link Enumerated} documentation.
     *
     * Visible for testing.
     *
     * @param method the method that returned the {@code enumObject}
     * @param enumObject the enum object that is being appended
     * @return the enum value to append
     */
    Object getEnumValueToAppend(Method method, Enum<?> enumObject) {
        Enumerated enumerated = method.getAnnotation(Enumerated.class);
        if (enumerated != null && enumerated.value() == EnumType.STRING) {
            return enumObject.name();
        }

        return enumObject.ordinal();
    }

    @Override
    public void flush() {
        long start = System.nanoTime();
        this.eventBus.post(new FlushEvent(this, EventFirePoint.BEFORE, this.aClass, this.tableName, start));
        super.flush();
        long end = System.nanoTime();
        logger.debug("Elapsed time to flush [{}] to database {}ms",
                this.aClass, TimeUnit.NANOSECONDS.toMillis(end - start));
        this.eventBus.post(new FlushEvent(this, EventFirePoint.AFTER, this.aClass, this.tableName, end));
    }

    private void generateAndSetId(E e) {
        if (this.autoGenerateId) {
            this.autoGeneratedId++;
            setIdValue(this.persistenceAnnotationInspector, e, this.autoGeneratedId);
        }
    }

    private Object invoke(Method method, Object target) {
        try {
            return method.invoke(target);
        }
        catch (InvocationTargetException | IllegalAccessException e) {
            throw propagate(e);
        }
    }

    public void setAutoGeneratedId(long autoGeneratedId) {
        this.autoGeneratedId = autoGeneratedId;
    }

    Collection<String> getAllColumns() {
        Set<String> columns = new LinkedHashSet<>(this.mappings.keySet());
        for (SingleInfileObjectLoader<Object> loader : this.embeds.values()) {
            columns.addAll(loader.getAllColumns());
        }
        return columns;
    }

    /**
     * Visible for testing.
     * @return the mappings for this object loader
     */
    Map<String, Method> getMappings() {
        return this.mappings;
    }

    /**
     * Visible for testing.
     * @return the embeds for this object loader
     */
    Map<Method, SingleInfileObjectLoader<Object>> getEmbeds() {
        return this.embeds;
    }

    /**
     * Visible for testing.
     * @return whether this loader should auto-generate an ID
     */
    boolean isAutoGenerateId() {
        return this.autoGenerateId;
    }

    /**
     * Visible for testing.
     * @return the infile data buffer
     */
    InfileDataBuffer getInfileDataBuffer() {
        return infileDataBuffer;
    }
}
